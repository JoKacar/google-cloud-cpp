diff --git a/google/cloud/bigtable/internal/readrowsparser.cc b/google/cloud/bigtable/internal/readrowsparser.cc
index b54c3d1..27fadba 100644
--- a/google/cloud/bigtable/internal/readrowsparser.cc
+++ b/google/cloud/bigtable/internal/readrowsparser.cc
@@ -36,12 +36,12 @@ void ReadRowsParser::HandleChunk(ReadRowsResponse_CellChunk chunk,
   }
 
   if (!chunk.row_key().empty()) {
-    if (last_seen_row_key_.compare(chunk.row_key()) >= 0) {
+    if (last_seen_row_key_.CompareTo(chunk.row_key()) >= 0) {
       status = grpc::Status(grpc::StatusCode::INTERNAL,
                             "Row keys are expected in increasing order");
       return;
     }
-    chunk.mutable_row_key()->swap(cell_.row);
+    chunk.mutable_row_key()->Swap(&cell_.row);
   }
 
   if (chunk.has_family_name()) {
@@ -54,7 +54,7 @@ void ReadRowsParser::HandleChunk(ReadRowsResponse_CellChunk chunk,
   }
 
   if (chunk.has_qualifier()) {
-    chunk.mutable_qualifier()->mutable_value()->swap(cell_.column);
+    chunk.mutable_qualifier()->mutable_value()->Swap(&cell_.column);
   }
 
   if (cell_first_chunk_) {
@@ -66,18 +66,13 @@ void ReadRowsParser::HandleChunk(ReadRowsResponse_CellChunk chunk,
 
   if (cell_first_chunk_) {
     // Most common case, move the value
-    chunk.mutable_value()->swap(cell_.value);
+    chunk.mutable_value()->Swap(&cell_.value);
   } else {
-    cell_.value.append(chunk.value());
+    cell_.value.Append(chunk.value());
   }
 
   cell_first_chunk_ = false;
 
-  // This is a hint we get about the total size
-  if (chunk.value_size() > 0) {
-    cell_.value.reserve(chunk.value_size());
-  }
-
   // Last chunk in the cell has zero for value size
   if (chunk.value_size() == 0) {
     if (cells_.empty()) {
@@ -150,7 +145,7 @@ Row ReadRowsParser::Next(grpc::Status& status) {
   if (!row_ready_) {
     status =
         grpc::Status(grpc::StatusCode::INTERNAL, "Next with row not ready");
-    return Row("", {});
+    return Row(absl::Cord(""), {});
   }
   row_ready_ = false;
 
